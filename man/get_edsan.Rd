% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/get_edsan.R
\name{get_edsan}
\alias{get_edsan}
\title{Retrieve EDSAN data with adaptive batching}
\usage{
get_edsan(
  module = c("doceds", "pmsi", "biol"),
  what = c("data", "idtriplets"),
  query = list(),
  start_date = NULL,
  end_date = NULL,
  periods_by = "1 month",
  periods_prefix = "{",
  periods_suffix = "}",
  batch_key = NULL,
  mode = c("auto", "time", "ids"),
  batch_ids_key = NULL,
  max_in_ids = 3500,
  min_in_ids = 50,
  max_out_units = 40000,
  output_count_fn = NULL,
  return_audit = FALSE,
  batch_on_error_only = TRUE,
  fallback_time_on_error = TRUE
)
}
\arguments{
\item{module}{One of `doceds`, `pmsi`, or `biol`.}

\item{what}{One of `data` or `idtriplets`.}

\item{query}{Named list of API query parameters.}

\item{start_date, end_date}{Optional Date bounds for time batching.}

\item{periods_by}{Size of each time chunk (passed to `seq`, e.g. "1 month").}

\item{periods_prefix, periods_suffix}{Strings wrapped around each time window.}

\item{batch_key}{Field used for time batching (defaults by module).}

\item{mode}{`auto`, `time`, or `ids` batching strategy.}

\item{batch_ids_key}{Field used for ID batching.}

\item{max_in_ids, min_in_ids}{Limits for input ID chunk sizes.}

\item{max_out_units}{Maximum output units before further splitting.}

\item{output_count_fn}{Function to count output units (defaults by module).}

\item{return_audit}{If `TRUE`, returns a list with `data` and `audit`.}

\item{batch_on_error_only}{If `TRUE`, time batching starts only after a limit error.}

\item{fallback_time_on_error}{If `TRUE`, ID batching can fall back to time batching.}
}
\value{
A data.frame/tibble, a list of results, or a list with audit metadata.
}
\description{
Wrapper around the EDSAN API that supports automatic time- or ID-based
batching to stay within API limits. For time batching, provide explicit
bounds in `query` or via `start_date`/`end_date`. For ID batching, provide
an ID field containing multiple IDs (vector or OR-separated string).
}
\details{
\strong{Overview}
\itemize{
\item \code{get_edsan()} wraps the EDSAN API and avoids backend limits by
batching requests and combining the results.
\item Batching can be time-based or ID-based depending on your query and
\code{mode}.
}

\strong{Mode decision (auto)}
\enumerate{
\item If the query contains a list of IDs, \code{auto} selects \code{ids}.
\item Otherwise it selects \code{time}.
}

\strong{Time batching}
\itemize{
\item Tries a single call first.
\item If a limit error occurs (and \code{batch_on_error_only = TRUE}),
splits the time window into \code{periods_by} chunks.
}

\strong{ID batching}
\itemize{
\item Splits the input ID list into chunks of size \code{max_in_ids}.
\item If a chunk still yields too much output, it is split again using
\code{max_out_units}.
\item Optional fallback to time batching can occur on limit errors.
}

\strong{Returned shapes}
\itemize{
\item \code{what = "data"} returns module-specific data (data.frame or list).
\item \code{what = "idtriplets"} returns a data.frame with \code{PATID},
\code{EVTID}, \code{ELTID}.
}

\strong{Audit output}
\itemize{
\item With \code{return_audit = TRUE}, the result is a list containing
\code{data} and an \code{audit} table of per-batch inputs/outputs/errors.
}

\strong{Common pitfalls}
\itemize{
\item Missing time bounds for time batching (\code{batch_key} not present).
\item Very large time windows that lead to slow or many batch calls.
\item ID lists with mixed separators; use vectors or \code{" OR "} strings.
}

\strong{Helper roles}
\itemize{
\item \code{.edsan_extract_bounds}: Parses API-style date bounds from the query.
\item \code{.edsan_infer_batch_window}: Determines a time window for batching.
\item \code{.edsan_split_id_string}: Normalizes ID vectors or OR-separated strings.
\item \code{.edsan_count_out_units}: Estimates output size to trigger splits.
\item \code{.edsan_combine}: Merges batch outputs into a single result.
}

\strong{Glossary}
\itemize{
\item \code{batch_key}: Query field used for time batching, e.g. \code{DATENT} or \code{DATEXAM}.
\item \code{bounds}: Date range like \code{\{YYYY-MM-DD,YYYY-MM-DD\}} or comparators \code{>YYYY-MM-DD}.
\item \code{limit error}: Backend error indicating too many results (quota/max rows).
\item \code{output units}: Heuristic count of returned rows or records used to trigger splitting.
\item \code{ids mode}: Batching strategy that splits the input ID list into chunks.
\item \code{time mode}: Batching strategy that splits a time range into periods.
}

\strong{Pseudo-flow (simplified)}
\preformatted{
get_edsan()
  -> decide mode (auto | time | ids)
  -> if time:
       try single call
       on limit error -> split into time periods -> combine
  -> if ids:
       split IDs into chunks
       if chunk too large -> split further
       optional time fallback on limit error
  -> return combined result (and audit if requested)
}
}
\examples{
\dontrun{
# Quick start: time batching
res <- get_edsan(
  module = "pmsi",
  what = "data",
  query = list(DATENT = "{2024-01-01,2024-01-31}"),
  periods_by = "1 week"
)

# Quick start: ID batching with audit output
out <- get_edsan(
  module = "biol",
  what = "data",
  query = list(PATID = "1 OR 2 OR 3"),
  mode = "ids",
  return_audit = TRUE
)
out$audit

# Doceds with explicit RECDATE bounds
doc <- get_edsan(
  module = "doceds",
  what = "data",
  query = list(RECDATE = "{2024-01-01,2024-01-31}")
)

# Minimal ids-mode with a vector of IDs
ids_out <- get_edsan(
  module = "pmsi",
  what = "idtriplets",
  query = list(PATID = c("10", "11", "12")),
  mode = "ids"
)
}
}
