% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/get_edsan.R
\name{get_edsan}
\alias{get_edsan}
\title{Retrieve EDSAN data with adaptive batching}
\usage{
get_edsan(
  module = c("doceds", "pmsi", "biol"),
  what = c("data", "idtriplets"),
  query = list(),
  start_date = NULL,
  end_date = NULL,
  periods_by = "1 month",
  periods_prefix = "{",
  periods_suffix = "}",
  batch_key = NULL,
  mode = c("auto", "time", "ids"),
  batch_ids_key = NULL,
  max_in_ids = 3500,
  min_in_ids = 50,
  max_out_units = 40000,
  output_count_fn = NULL,
  return_audit = FALSE,
  batch_on_error_only = TRUE,
  fallback_time_on_error = TRUE
)
}
\arguments{
\item{module}{One of `doceds`, `pmsi`, or `biol`.}

\item{what}{One of `data` or `idtriplets`.}

\item{query}{Named list of API query parameters.}

\item{start_date, end_date}{Optional Date bounds for time batching.}

\item{periods_by}{Size of each time chunk (passed to `seq`, e.g. "1 month").}

\item{periods_prefix, periods_suffix}{Strings wrapped around each time window.}

\item{batch_key}{Field used for time batching (defaults by module).}

\item{mode}{`auto`, `time`, or `ids` batching strategy.}

\item{batch_ids_key}{Field used for ID batching.}

\item{max_in_ids, min_in_ids}{Limits for input ID chunk sizes.}

\item{max_out_units}{Maximum output units before further splitting.}

\item{output_count_fn}{Function to count output units (defaults by module).}

\item{return_audit}{If `TRUE`, returns a list with `data` and `audit`.}

\item{batch_on_error_only}{If `TRUE`, time batching starts only after a limit error.}

\item{fallback_time_on_error}{If `TRUE`, ID batching can fall back to time batching.}
}
\value{
A data.frame/tibble, a list of results, or a list with audit metadata.
}
\description{
Wrapper around the EDSAN API that supports automatic time- or ID-based
batching to stay within API limits. For time batching, provide explicit
bounds in `query` or via `start_date`/`end_date`. For ID batching, provide
an ID field containing multiple IDs (vector or OR-separated string).
}
\details{
The EDSAN backend enforces strict result size limits, so `get_edsan()` uses
adaptive batching to reduce failures and retry with smaller chunks.

Decision flow (high level):
\itemize{
\item `mode = "auto"` chooses `ids` batching if the query contains a list of
IDs; otherwise it uses time batching.
\item `mode = "time"` attempts a single call first, then splits the time
window into `periods_by` chunks only after a limit error (when
`batch_on_error_only = TRUE`).
\item `mode = "ids"` splits the input ID list into chunks (`max_in_ids`) and
further subdivides when a chunk still returns too many rows (`max_out_units`).
\item Optional `return_audit = TRUE` yields a per-batch table with inputs,
outputs, and errors for debugging.
}

Helper roles:
\describe{
\item{.edsan_extract_bounds}{Parses API-style date bounds from the query.}
\item{.edsan_infer_batch_window}{Determines a time window for batching.}
\item{.edsan_split_id_string}{Normalizes ID vectors or OR-separated strings.}
\item{.edsan_count_out_units}{Estimates output size to trigger splits.}
\item{.edsan_combine}{Merges batch outputs into a single result.}
}

Glossary:
\describe{
\item{batch_key}{Query field used for time batching, e.g. `DATENT` or `DATEXAM`.}
\item{bounds}{Date range like `{YYYY-MM-DD,YYYY-MM-DD}` or comparators `>YYYY-MM-DD`.}
\item{limit error}{Backend error indicating too many results (quota/max rows).}
\item{output units}{Heuristic count of returned rows or records used to trigger splitting.}
\item{ids mode}{Batching strategy that splits the input ID list into chunks.}
\item{time mode}{Batching strategy that splits a time range into periods.}
}

Pseudo-flow (simplified):
\preformatted{
get_edsan()
  -> decide mode (auto | time | ids)
  -> if time:
       try single call
       on limit error -> split into time periods -> combine
  -> if ids:
       split IDs into chunks
       if chunk too large -> split further
       optional time fallback on limit error
  -> return combined result (and audit if requested)
}
}
\examples{
\dontrun{
# Time batching using explicit bounds
res <- get_edsan(
  module = "pmsi",
  what = "data",
  query = list(DATENT = "{2024-01-01,2024-01-31}"),
  periods_by = "1 week"
)

# ID batching with audit output
out <- get_edsan(
  module = "biol",
  what = "data",
  query = list(PATID = "1 OR 2 OR 3"),
  mode = "ids",
  return_audit = TRUE
)
out$audit

# Doceds example with explicit RECDATE bounds
doc <- get_edsan(
  module = "doceds",
  what = "data",
  query = list(RECDATE = "{2024-01-01,2024-01-31}")
)

# Minimal ids-mode example with a vector of IDs
ids_out <- get_edsan(
  module = "pmsi",
  what = "idtriplets",
  query = list(PATID = c("10", "11", "12")),
  mode = "ids"
)
}
}
